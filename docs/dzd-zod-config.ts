import { z } from "@/infra/ct-zod";
import { zUndefinedNever, type ZUndefinedNever } from "@/infra/ct-zod/zod-never";
import { type AnyOf, undefinedableToBool } from "@/infra/ts-utils/configuration-types";

/** Config + compile-time flag extraction (defaults undefined -> false) */
export type DzdZodConfig = {
  isOptional?: boolean; // makes the field optional (optional on create; update is always optional)
  isNullable?: boolean; // makes the field nullable (nullable on create/read/update)
  isReadonly?: boolean; // makes the field readonly (never on create/update)
  isImmutable?: boolean; // makes the field immutable (readonly on update)
  requiredOnUpdate?: boolean; // makes the field required on update (not optional)
  generatedOnCreate?: boolean; // never on create - generated by db (readonly on create)
  generatedOnUpdate?: boolean; // never on update - generated by db (readonly on update)
};
export const defaultDzdZodConfig = {
  isOptional: false,
  isNullable: false,
  isReadonly: false,
  isImmutable: false,
  requiredOnUpdate: false,
  generatedOnCreate: false,
  generatedOnUpdate: false,
} as const;

type Optionalize<T extends z.ZodTypeAny, B extends boolean> =
  B extends true ? z.ZodOptional<T> : T;
type Nullablize<T extends z.ZodTypeAny, B extends boolean> =
  B extends true ? z.ZodNullable<T> : T;
type Readonlyize<T extends z.ZodTypeAny, B extends boolean> =
  B extends true ? ZUndefinedNever : T;

type OptOf<C> =
  C extends { isOptional?: infer B } ? (B extends true ? true : false) : false;
type NullOf<C> =
  C extends { isNullable?: infer B } ? (B extends true ? true : false) : false;
type ReadonlyOf<C> =
  C extends { isReadonly?: infer B } ? (B extends true ? true : false) : false;
type ImmutableOf<C> =
  C extends { isImmutable?: infer B } ? (B extends true ? true : false) : false;
type RequiredOnUpdateOf<C> =
  C extends { requiredOnUpdate?: infer B } ? (B extends true ? true : false) : false;
type GeneratedOnCreateOf<C> =
  C extends { generatedOnCreate?: infer B } ? (B extends true ? true : false) : false;
type GeneratedOnUpdateOf<C> =
  C extends { generatedOnUpdate?: infer B } ? (B extends true ? true : false) : false;

export function maybeOptional<
  T extends z.ZodTypeAny,
  const B extends boolean
>(s: T, b: B): Optionalize<T, B> {
  return (b ? s.optional() : s) as Optionalize<T, B>;
}
export function maybeNullable<
  T extends z.ZodTypeAny,
  const B extends boolean
>(s: T, b: B): Nullablize<T, B> {
  return (b ? s.nullable() : s) as Nullablize<T, B>;
}
export function maybeReadonly<
  T extends z.ZodTypeAny,
  const B extends boolean
>(s: T, b: B): Readonlyize<T, B> {
  return (b ? zUndefinedNever : s) as Readonlyize<T, B>;
}

type ApplyFlagsForCreate<T extends z.ZodTypeAny, Opt extends boolean, Null extends boolean, Readonly extends boolean, GeneratedOnCreate extends boolean> =
  Readonlyize<
    Optionalize<
      Nullablize<T, Null>,
    Opt>,
  AnyOf<[Readonly, GeneratedOnCreate]>
>;

type ApplyFlagsForRead<T extends z.ZodTypeAny, Null extends boolean> =
  Nullablize<T, Null>;

type ApplyFlagsForUpdate<T extends z.ZodTypeAny, Null extends boolean, Readonly extends boolean, Immutable extends boolean, RequiredOnUpdate extends boolean, GeneratedOnUpdate extends boolean> =
  Readonlyize<
      Optionalize<
        Nullablize<T, Null>,
        RequiredOnUpdate extends true ? false : true  // If required on update, don't make optional
      >,
  AnyOf<[Readonly, Immutable, GeneratedOnUpdate]>>;

export function withZodConfigForCreate<
  T extends z.ZodTypeAny,
  const C extends DzdZodConfig | undefined = undefined
>(schema: T, cfg?: C): ApplyFlagsForCreate<T, OptOf<C>, NullOf<C>, ReadonlyOf<C>, GeneratedOnCreateOf<C>> {
  const o = undefinedableToBool(cfg?.isOptional);
  const n = undefinedableToBool(cfg?.isNullable);
  const r = undefinedableToBool(cfg?.isReadonly) || undefinedableToBool(cfg?.generatedOnCreate);
  return (
    maybeReadonly(
      maybeOptional(
        maybeNullable(schema, n),
        o
      ),
      r
    )
  ) as ApplyFlagsForCreate<T, OptOf<C>, NullOf<C>, ReadonlyOf<C>, GeneratedOnCreateOf<C>>;
}
export function withZodConfigForRead<
  T extends z.ZodTypeAny,
  const C extends DzdZodConfig | undefined = undefined
>(schema: T, cfg?: C): ApplyFlagsForRead<T, NullOf<C>> {
  const isNullable = undefinedableToBool(cfg?.isNullable);
  return maybeNullable(schema, isNullable) as ApplyFlagsForRead<T, NullOf<C>>;
}

export function withZodConfigForUpdate<
  T extends z.ZodTypeAny,
  const C extends DzdZodConfig | undefined = undefined
>(schema: T, cfg?: C): ApplyFlagsForUpdate<T, NullOf<C>, ReadonlyOf<C>, ImmutableOf<C>, RequiredOnUpdateOf<C>, GeneratedOnUpdateOf<C>> {
  const isNullable = undefinedableToBool(cfg?.isNullable);
  const isImuutable = undefinedableToBool(cfg?.isImmutable);
  const isGenerated = undefinedableToBool(cfg?.generatedOnUpdate);
  const isReadonly = undefinedableToBool(cfg?.isReadonly) || isImuutable || isGenerated;
  const isOptional = !undefinedableToBool(cfg?.requiredOnUpdate);
  
  return (
    maybeReadonly(
      maybeOptional(
        maybeNullable(schema, isNullable),
        isOptional
      ),
      isReadonly
    )
  ) as ApplyFlagsForUpdate<T, NullOf<C>, ReadonlyOf<C>, ImmutableOf<C>, RequiredOnUpdateOf<C>, GeneratedOnUpdateOf<C>>;
}

/** ---------- COMPILE-TIME TESTS ---------- */
const _test_base = z.number();
type _TestBase = typeof _test_base;

// Compile-time test dictionary for withZodConfigForCreate
const _createTests = {
  // Base tests
  pure: withZodConfigForCreate(_test_base) as _TestBase,
  emptyConfig: withZodConfigForCreate(_test_base, {}) as _TestBase,
  undefinedFields: withZodConfigForCreate(_test_base, {isOptional: undefined, isNullable: undefined, isReadonly: undefined, isImmutable: undefined, requiredOnUpdate: undefined, generatedOnCreate: undefined, generatedOnUpdate: undefined}) as _TestBase,
  
  // Single option tests
  optional: withZodConfigForCreate(_test_base, { isOptional: true }) as z.ZodOptional<_TestBase>,
  nullable: withZodConfigForCreate(_test_base, { isNullable: true }) as z.ZodNullable<_TestBase>,
  readonly: withZodConfigForCreate(_test_base, { isReadonly: true }) as ZUndefinedNever,
  immutable: withZodConfigForCreate(_test_base, { isImmutable: true }) as _TestBase,  // Immutable is ignored for create
  requiredOnUpdate: withZodConfigForCreate(_test_base, { requiredOnUpdate: true }) as _TestBase,  // requiredOnUpdate is ignored for create
  generatedOnCreate: withZodConfigForCreate(_test_base, { generatedOnCreate: true }) as ZUndefinedNever,
  generatedOnUpdate: withZodConfigForCreate(_test_base, { generatedOnUpdate: true }) as _TestBase,  // generatedOnUpdate is ignored for create
  
  // Two option combinations
  optionalNullable: withZodConfigForCreate(_test_base, { isOptional: true, isNullable: true }) as z.ZodOptional<z.ZodNullable<_TestBase>>,
  optionalReadonly: withZodConfigForCreate(_test_base, { isOptional: true, isReadonly: true }) as ZUndefinedNever,
  optionalImmutable: withZodConfigForCreate(_test_base, { isOptional: true, isImmutable: true }) as z.ZodOptional<_TestBase>,  // Immutable ignored
  nullableReadonly: withZodConfigForCreate(_test_base, { isNullable: true, isReadonly: true }) as ZUndefinedNever,
  nullableImmutable: withZodConfigForCreate(_test_base, { isNullable: true, isImmutable: true }) as z.ZodNullable<_TestBase>,  // Immutable ignored
  readonlyImmutable: withZodConfigForCreate(_test_base, { isReadonly: true, isImmutable: true }) as ZUndefinedNever,  // readonly takes precedence, immutable ignored
  
  // Three option combinations
  optionalNullableReadonly: withZodConfigForCreate(_test_base, { isOptional: true, isNullable: true, isReadonly: true }) as ZUndefinedNever,
  optionalNullableImmutable: withZodConfigForCreate(_test_base, { isOptional: true, isNullable: true, isImmutable: true }) as z.ZodOptional<z.ZodNullable<_TestBase>>,  // Immutable ignored
  optionalReadonlyImmutable: withZodConfigForCreate(_test_base, { isOptional: true, isReadonly: true, isImmutable: true }) as ZUndefinedNever,  // readonly takes precedence
  nullableReadonlyImmutable: withZodConfigForCreate(_test_base, { isNullable: true, isReadonly: true, isImmutable: true }) as ZUndefinedNever,  // readonly takes precedence
  
  // Four option combination
  optionalNullableReadonlyImmutable: withZodConfigForCreate(_test_base, { isOptional: true, isNullable: true, isReadonly: true, isImmutable: true }) as ZUndefinedNever,  // readonly takes precedence
  
  // New flag combinations with existing flags
  optionalGeneratedOnCreate: withZodConfigForCreate(_test_base, { isOptional: true, generatedOnCreate: true }) as ZUndefinedNever,
  nullableGeneratedOnCreate: withZodConfigForCreate(_test_base, { isNullable: true, generatedOnCreate: true }) as ZUndefinedNever,
  readonlyGeneratedOnCreate: withZodConfigForCreate(_test_base, { isReadonly: true, generatedOnCreate: true }) as ZUndefinedNever,
  
  // Explicit false combinations
  readonlyFalseOptional: withZodConfigForCreate(_test_base, { isOptional: true, isReadonly: false }) as z.ZodOptional<_TestBase>,
  readonlyFalseNullable: withZodConfigForCreate(_test_base, { isNullable: true, isReadonly: false }) as z.ZodNullable<_TestBase>,
  readonlyFalseOptionalNullable: withZodConfigForCreate(_test_base, { isOptional: true, isNullable: true, isReadonly: false }) as z.ZodOptional<z.ZodNullable<_TestBase>>,
  immutableFalseOptional: withZodConfigForCreate(_test_base, { isOptional: true, isImmutable: false }) as z.ZodOptional<_TestBase>,  // Immutable ignored anyway
  immutableFalseNullable: withZodConfigForCreate(_test_base, { isNullable: true, isImmutable: false }) as z.ZodNullable<_TestBase>,  // Immutable ignored anyway
  generatedOnCreateFalse: withZodConfigForCreate(_test_base, { isOptional: true, generatedOnCreate: false }) as z.ZodOptional<_TestBase>,
} as const;

// Compile-time test dictionary for withZodConfigForRead
const _readTests = {
  // Base tests
  pure: withZodConfigForRead(_test_base) as _TestBase,
  emptyConfig: withZodConfigForRead(_test_base, {}) as _TestBase,
  undefinedFields: withZodConfigForRead(_test_base, {isOptional: undefined, isNullable: undefined, isReadonly: undefined, isImmutable: undefined, requiredOnUpdate: undefined, generatedOnCreate: undefined, generatedOnUpdate: undefined}) as _TestBase,
  
  // Single option tests (only nullable matters for read - all other flags are ignored)
  optional: withZodConfigForRead(_test_base, { isOptional: true }) as _TestBase, // isOptional ignored in read
  nullable: withZodConfigForRead(_test_base, { isNullable: true }) as z.ZodNullable<_TestBase>,
  readonly: withZodConfigForRead(_test_base, { isReadonly: true }) as _TestBase, // isReadonly ignored in read
  immutable: withZodConfigForRead(_test_base, { isImmutable: true }) as _TestBase, // isImmutable ignored in read
  requiredOnUpdate: withZodConfigForRead(_test_base, { requiredOnUpdate: true }) as _TestBase, // requiredOnUpdate ignored in read
  generatedOnCreate: withZodConfigForRead(_test_base, { generatedOnCreate: true }) as _TestBase, // generatedOnCreate ignored in read
  generatedOnUpdate: withZodConfigForRead(_test_base, { generatedOnUpdate: true }) as _TestBase, // generatedOnUpdate ignored in read
  
  // Combinations (only nullable matters for read)
  optionalNullable: withZodConfigForRead(_test_base, { isOptional: true, isNullable: true }) as z.ZodNullable<_TestBase>,
  optionalReadonly: withZodConfigForRead(_test_base, { isOptional: true, isReadonly: true }) as _TestBase,
  optionalImmutable: withZodConfigForRead(_test_base, { isOptional: true, isImmutable: true }) as _TestBase, // immutable ignored
  nullableReadonly: withZodConfigForRead(_test_base, { isNullable: true, isReadonly: true }) as z.ZodNullable<_TestBase>,
  nullableImmutable: withZodConfigForRead(_test_base, { isNullable: true, isImmutable: true }) as z.ZodNullable<_TestBase>, // immutable ignored
  readonlyImmutable: withZodConfigForRead(_test_base, { isReadonly: true, isImmutable: true }) as _TestBase, // both ignored
  optionalNullableReadonly: withZodConfigForRead(_test_base, { isOptional: true, isNullable: true, isReadonly: true }) as z.ZodNullable<_TestBase>,
  optionalNullableImmutable: withZodConfigForRead(_test_base, { isOptional: true, isNullable: true, isImmutable: true }) as z.ZodNullable<_TestBase>, // immutable ignored
  optionalReadonlyImmutable: withZodConfigForRead(_test_base, { isOptional: true, isReadonly: true, isImmutable: true }) as _TestBase, // readonly and immutable ignored
  nullableReadonlyImmutable: withZodConfigForRead(_test_base, { isNullable: true, isReadonly: true, isImmutable: true }) as z.ZodNullable<_TestBase>, // readonly and immutable ignored
  optionalNullableReadonlyImmutable: withZodConfigForRead(_test_base, { isOptional: true, isNullable: true, isReadonly: true, isImmutable: true }) as z.ZodNullable<_TestBase>, // readonly and immutable ignored
} as const;

// Compile-time test dictionary for withZodConfigForUpdate
const _updateTests = {
  // Base tests
  pure: withZodConfigForUpdate(_test_base) as z.ZodOptional<_TestBase>, // always optional in update
  emptyConfig: withZodConfigForUpdate(_test_base, {}) as z.ZodOptional<_TestBase>,
  undefinedFields: withZodConfigForUpdate(_test_base, {isOptional: undefined, isNullable: undefined, isReadonly: undefined, isImmutable: undefined, requiredOnUpdate: undefined, generatedOnCreate: undefined, generatedOnUpdate: undefined}) as z.ZodOptional<_TestBase>,
  
  // Single option tests
  optional: withZodConfigForUpdate(_test_base, { isOptional: true }) as z.ZodOptional<_TestBase>, // isOptional forced to true in update anyway
  nullable: withZodConfigForUpdate(_test_base, { isNullable: true }) as z.ZodOptional<z.ZodNullable<_TestBase>>,
  readonly: withZodConfigForUpdate(_test_base, { isReadonly: true }) as ZUndefinedNever,
  immutable: withZodConfigForUpdate(_test_base, { isImmutable: true }) as ZUndefinedNever, // immutable prevents updates
  requiredOnUpdate: withZodConfigForUpdate(_test_base, { requiredOnUpdate: true }) as _TestBase, // required on update - not optional
  generatedOnCreate: withZodConfigForUpdate(_test_base, { generatedOnCreate: true }) as z.ZodOptional<_TestBase>, // generatedOnCreate ignored on update
  generatedOnUpdate: withZodConfigForUpdate(_test_base, { generatedOnUpdate: true }) as ZUndefinedNever, // generatedOnUpdate prevents updates
  
  // Combinations
  optionalNullable: withZodConfigForUpdate(_test_base, { isOptional: true, isNullable: true }) as z.ZodOptional<z.ZodNullable<_TestBase>>,
  optionalReadonly: withZodConfigForUpdate(_test_base, { isOptional: true, isReadonly: true }) as ZUndefinedNever,
  optionalImmutable: withZodConfigForUpdate(_test_base, { isOptional: true, isImmutable: true }) as ZUndefinedNever, // immutable prevents updates
  nullableReadonly: withZodConfigForUpdate(_test_base, { isNullable: true, isReadonly: true }) as ZUndefinedNever,
  nullableImmutable: withZodConfigForUpdate(_test_base, { isNullable: true, isImmutable: true }) as ZUndefinedNever, // immutable prevents updates
  
  // New flag combinations
  requiredOnUpdateNullable: withZodConfigForUpdate(_test_base, { requiredOnUpdate: true, isNullable: true }) as z.ZodNullable<_TestBase>, // required + nullable
  requiredOnUpdateReadonly: withZodConfigForUpdate(_test_base, { requiredOnUpdate: true, isReadonly: true }) as ZUndefinedNever, // readonly takes precedence
  generatedOnUpdateNullable: withZodConfigForUpdate(_test_base, { generatedOnUpdate: true, isNullable: true }) as ZUndefinedNever, // generatedOnUpdate takes precedence
  requiredOnUpdateGeneratedOnUpdate: withZodConfigForUpdate(_test_base, { requiredOnUpdate: true, generatedOnUpdate: true }) as ZUndefinedNever, // generatedOnUpdate takes precedence
  readonlyImmutable: withZodConfigForUpdate(_test_base, { isReadonly: true, isImmutable: true }) as ZUndefinedNever, // both prevent updates, readonly applied last
  optionalNullableReadonly: withZodConfigForUpdate(_test_base, { isOptional: true, isNullable: true, isReadonly: true }) as ZUndefinedNever,
  optionalNullableImmutable: withZodConfigForUpdate(_test_base, { isOptional: true, isNullable: true, isImmutable: true }) as ZUndefinedNever, // immutable prevents updates
  optionalReadonlyImmutable: withZodConfigForUpdate(_test_base, { isOptional: true, isReadonly: true, isImmutable: true }) as ZUndefinedNever, // both prevent updates, readonly applied last
  nullableReadonlyImmutable: withZodConfigForUpdate(_test_base, { isNullable: true, isReadonly: true, isImmutable: true }) as ZUndefinedNever, // both prevent updates, readonly applied last
  optionalNullableReadonlyImmutable: withZodConfigForUpdate(_test_base, { isOptional: true, isNullable: true, isReadonly: true, isImmutable: true }) as ZUndefinedNever, // both prevent updates, readonly applied last
} as const;